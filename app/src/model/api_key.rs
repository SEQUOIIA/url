use db::api_keys;
use serde::{Serialize, Deserialize};

pub struct ApiKey {
    pub id : i64,
    pub key : String,
    pub description : Option<String>
}

#[derive(Serialize, Deserialize)]
pub struct ApiKeyPostRequest {
    pub description : Option<String>
}

#[derive(Serialize, Deserialize)]
pub struct ApiKeyPostResponse {
    pub key : String
}

#[derive(Serialize, Deserialize)]
pub struct ApiKeyDeleteRequest {
    pub key : String
}


impl From<ApiKeyDb> for ApiKey {
    fn from(u: ApiKeyDb) -> Self {
        Self {
            id: u.id,
            description: u.description,
            key: u.key
        }
    }
}
impl PartialEq for ApiKey {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id && self.key == other.key
    }
}

#[derive(Queryable, Identifiable)]
#[table_name="api_keys"]
pub struct ApiKeyDb {
    pub id : i64,
    pub key : String,
    pub description : Option<String>
}

impl From<ApiKey> for ApiKeyDb {
    fn from(u: ApiKey) -> Self {
        Self {
            id: u.id,
            description: u.description,
            key: u.key
        }
    }
}

#[derive(Insertable)]
#[table_name="api_keys"]
pub struct ApiKeyDbInsert {
    pub key : String,
    pub description : Option<String>
}

// Manually maintained instead of using the autogenerated schema.rs
// Due to the stubborn stance of the Diesel maintainers on this subject:
// https://github.com/diesel-rs/diesel/issues/852
// https://github.com/diesel-rs/diesel/issues/2638
// https://github.com/diesel-rs/diesel/issues/1116
pub mod db {
    use diesel::table;
    table! {
    api_keys (id) {
        id -> BigInt,
        key -> Text,
        description -> Nullable<Text>,
    }
}
}